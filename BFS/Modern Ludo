using System;
using System.Collections;
using System.Collections.Generic;

namespace lintcode
{
    class Solution {
        /**
         * @param length: the length of board
         * @param connections: the connections of the positions
         * @return: the minimum steps to reach the end
         */
        public int ModernLudo(int length, int[][] connections) {
            // Write your code here
            var graph = BuildGraph(length, connections);

            return Bfs(length, graph);
        }

        private int  Bfs(int length, Dictionary<int, HashSet<int>> graph) {
            Queue<int> queue = new Queue<int>();
            Dictionary<int, int> distance = new Dictionary<int, int>();
            queue.Enqueue(1);
            distance[1] = 0;
            while (queue.Count > 0) {
                int node = queue.Dequeue();
                for (int i = node + 1; i < Math.Min(node + 7, length + 1); i++) {
                    var neighbors = GetUnvisitedNodes(i, graph, distance);
                    foreach (var neighbor in neighbors) {
                        distance[neighbor] = distance[node] + 1;
                        queue.Enqueue(neighbor);
                    }
                }
            }

            return distance[length];
        }

        private HashSet<int> GetUnvisitedNodes(int node, Dictionary<int, HashSet<int>> graph, Dictionary<int, int> distance) {
            Queue<int> queue = new Queue<int>();
            HashSet<int> set = new HashSet<int>();
            queue.Enqueue(node);
            while (queue.Count > 0) {
                var index = queue.Dequeue();
                if (distance.ContainsKey(index))
                    continue;

                set.Add(index); //?
                foreach (var neighbor in graph[index]) {
                    if (distance.ContainsKey(neighbor))
                        continue;
                    
                    if (set.Contains(neighbor))
                        continue;
                    
                    set.Add(neighbor);
                    queue.Enqueue(neighbor);
                }
            }
            
            return set;
        }

        private Dictionary<int, HashSet<int>> BuildGraph(int length, int[][] connections) {
            Dictionary<int, HashSet<int>> graph = new Dictionary<int, HashSet<int>>();
            for (int i = 1; i <= length; i++) {
                graph[i] = new HashSet<int>();
            }
            foreach (var item in connections) {
                graph[item[0]].Add(item[1]);
            }
            
            return graph;
        }
    }
}